
# C++ `dsa` Library Roadmap

## Phase 1: Data Structures Implementation

- [X] **Static Arrays**
  - [X] Indexing
  - [X] Linear Search

- [X] **Dynamic Arrays**
  - [X] Indexing
  - [X] Search
  - [X] Push back
  - [X] Pop back
  - [X] Push front
  - [X] Pop Front
  - [X] Insert
  - [X] Remove


- [ ] **Strings**

- [ ] **Linked Lists**
  - [ ] Implement Singly and Doubly Linked Lists
  - [ ] Operations: Insertion, Deletion, Reversal

- [ ] **Stacks and Queues**
  - [ ] Implement Stack and Queue using arrays and linked lists
  - [ ] Implement special cases: Min Stack, Circular Queue

- [ ] **Hash Tables / Maps / Sets**
  - [ ] Implement basic hash functions, handle collisions
  - [ ] Practice operations: Insert, Delete, Search

- [ ] **Binary Trees and Binary Search Trees**
  - [ ] Implement Binary Tree and Binary Search Tree (BST)
  - [ ] Operations: Traversals (DFS, BFS), Insert, Delete, Search, Height, Diameter

- [ ] **Heaps (Priority Queues)**
  - [ ] Implement Min Heap and Max Heap
  - [ ] Operations: Insert, Delete, Peek, Heapify

- [ ] **Graphs**
  - [ ] Representations: Adjacency List, Adjacency Matrix
  - [ ] Traversals: BFS, DFS
  - [ ] Implement algorithms: Dijkstra, Bellman-Ford, Floyd-Warshall

## Phase 2: Algorithms Implementation

- [ ] **Sorting Algorithms**
  - [ ] Implement common sorts: Bubble, Selection, Insertion, Merge, Quick, Heap
  - [ ] Practice: Time complexity analysis, Space complexity trade-offs

- [ ] **Search Algorithms**
  - [ ] Linear Search, Binary Search (including recursive versions)
  - [ ] Variants: Lower Bound, Upper Bound, Binary Search on rotated arrays
  - [ ] LeetCode: "Search in Rotated Sorted Array", "First Bad Version"

- [ ] **Dynamic Programming**
  - [ ] Practice on common problems: Knapsack, Fibonacci, Longest Increasing Subsequence
  - [ ] LeetCode: "Climbing Stairs", "Longest Palindromic Subsequence"

- [ ] **Greedy Algorithms**
  - [ ] Practice classic problems: Interval Scheduling, Huffman Coding
  - [ ] LeetCode: "Jump Game", "Greedy Algorithm to Minimize Total Cost"

- [ ] **Backtracking**
  - [ ] Problems: Permutations, Combinations, N-Queens
  - [ ] LeetCode: "Word Search", "Subsets"

- [ ] **Divide and Conquer**
  - [ ] Implement common divide-and-conquer strategies: Binary Search, Merge Sort
  - [ ] LeetCode: "Majority Element", "Maximum Subarray"

- [ ] **Bit Manipulation**
  - [ ] Basic bit operations: AND, OR, XOR, Shifts
  - [ ] LeetCode: "Single Number", "Number of 1 Bits"

## Phase 3: Advanced Topics for Interviews

- [ ] **Trie (Prefix Tree)**
  - [ ] Implement Trie for storing strings, common operations (Insert, Search)
  - [ ] LeetCode: "Implement Trie", "Word Search II"

- [ ] **Segment Trees / Binary Indexed Trees (Fenwick Tree)**
  - [ ] Implement Segment Tree and Binary Indexed Tree for range queries
  - [ ] LeetCode: "Range Sum Query", "Count of Smaller Numbers After Self"

- [ ] **Union-Find (Disjoint Set Union)**
  - [ ] Implement Union-Find with path compression and union by rank
  - [ ] LeetCode: "Graph Valid Tree", "Number of Connected Components"

- [ ] **Topological Sort**
  - [ ] Implement Kahnâ€™s Algorithm, DFS for topological sorting
  - [ ] LeetCode: "Course Schedule II", "Alien Dictionary"

## Phase 4: Practice and Optimization

- [ ] **LeetCode Patterns**
  - [ ] Solve problems based on patterns: Sliding Window, Top K Elements, Fast & Slow Pointers
  - [ ] Focus on medium and hard LeetCode problems

- [ ] **Time and Space Optimization**
  - [ ] Learn how to optimize algorithms for space and time complexity
  - [ ] Focus on techniques like memoization, tail recursion, and pruning
